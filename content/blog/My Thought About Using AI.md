---
tags:
  - blog
---
I’ve been using AI since the first release of ChatGPT. I’ve experimented with it in all kinds of ways — from coding assistance to learning and research. And here’s what I’ve learned after all this time:

AI is great. It really is. It can replace some parts of a developer’s work.  
But if you **use it without thinking**, it will slowly **replace your brain** too.

I’m not against AI — I actually use it a lot in my daily work.  
But I refuse to let it **think for me**.

Here’s what I see many developers doing wrong:  
They take a business requirement, copy it, and paste it straight into an AI prompt saying,

> “Create this app for me.”

That’s the _dumbest_ way to use AI.  
If you do that, you’re not a developer — you’re just a **middleman between a requirement and a chatbot**.

A real developer should:

- **Understand** the problem first.
    
- **Summarize** the business requirement.
    
- **Think and design** a solution logically.
    
- **Write the core logic** by themselves.
    

Then, **after** that, use AI for what it’s actually good at:

- Creating a quick **POC (proof of concept)**
    
- Doing **research** like “how to optimize this algorithm”
    
- Or **reviewing** your existing code to catch mistakes
    

But if you let AI handle everything from the start, it will **frame your thinking**.  
You’ll get stuck inside the box that AI creates for you.

When something goes wrong — say your code has bugs or doesn’t fit the business logic —  
you’ll realize how hard it is to debug code that **you didn’t truly write**.  
It’s like trying to fix someone else’s logic that you never understood.

And if the developer who’s assigned to that task doesn’t understand their own code,  
how can anyone else understand it?

Sure, you could ask AI to explain it again:

> “Hey AI, can you summarize what this code does?”

But let me ask you this —  
if AI **lies** or **makes a wrong assumption**,  
how would you even know?

The best way to use AI is to let it handle the **boring parts** —  
like reading long documentation, summarizing repetitive content, or generating boilerplate code.  
But the **thinking** — that’s still your job.

Because once you stop thinking,  
you’re no longer the developer.  
You’re just the operator of someone else’s brain.
